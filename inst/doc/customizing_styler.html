<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Lorenz Walthert" />


<title>Customizing styler</title>



<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#header {
text-align: center;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; }  code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>

</head>

<body>




<h1 class="title toc-ignore">Customizing styler</h1>
<h4 class="author"><em>Lorenz Walthert</em></h4>
<h4 class="date"><em>8/10/2017</em></h4>



<p>This vignette provides a high-level overview of how styler works and how you can define your own style guide and format code according to it.</p>
<div id="how-styler-works" class="section level1">
<h1>How styler works</h1>
<p>There are three major steps that styler performs in order to style code:</p>
<ol style="list-style-type: decimal">
<li>Create an abstract syntax tree (AST) from <code>utils::getParseData()</code> that contains positional information for every token. We call this a nested parse table. You can learn more about how exactly this is done in the vignettes “Data Structures” and “Manipulating the nested parse table”.</li>
<li>Apply transformer functions at each level of the nested parse table. We use a visitor approach, i.e. a function that takes functions as arguments and applies them to every level of nesting. You can find out more about it on the help file for <code>visit()</code>. Note that the function is not exported by styler. The visitor will take care of applying the functions on every level of nesting - and we can supply transformer functions that operate on one level of nesting. In the sequel, we use the term <em>nest</em> to refer to such a parse table at one level of nesting. A <em>nest</em> always represents a complete expression. Before we apply the transformers, we have to initialize two columns <code>lag_newlines</code> and <code>spaces</code>, which contain the number of line breaks before the token and the number of spaces after the token. These will be the columns that most of our transformer functions will modify.</li>
<li>Serialize the nested parse table, that is, extract the terminal tokens from the nested parse table and add spaces and line breaks between them as specified in the nested parse table.</li>
</ol>
<p>The <code>transformers</code> argument is, apart from the code to style, the key argument of functions such as <code>style_text()</code> and friends. By default, it is created via the <code>style</code> argument. The transformers are a named list of transformer functions and other arguments passed to styler. To use the default style guide of styler (<a href="http://style.tidyverse.org/">the tidyverse style guide</a>), call <code>tidyverse_style()</code> to get the list of the transformer functions. Let’s quickly look at what those are.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">library</span>(<span class="st">&quot;styler&quot;</span>)</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="kw">library</span>(<span class="st">&quot;dplyr&quot;</span>)</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">names</span>(<span class="kw">tidyverse_style</span>())</a></code></pre></div>
<pre><code>## [1] &quot;initialize&quot;        &quot;line_break&quot;        &quot;space&quot;            
## [4] &quot;token&quot;             &quot;indention&quot;         &quot;use_raw_indention&quot;
## [7] &quot;reindention&quot;</code></pre>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">str</span>(<span class="kw">tidyverse_style</span>(), <span class="dt">give.attr =</span> <span class="ot">FALSE</span>, <span class="dt">list.len =</span> <span class="dv">3</span>)</a></code></pre></div>
<pre><code>## List of 7
##  $ initialize       :List of 1
##   ..$ initialize:function (pd_flat)  
##  $ line_break       :List of 8
##   ..$ remove_line_break_before_curly_opening            :function (pd)  
##   ..$ remove_line_break_before_round_closing_after_curly:function (pd)  
##   ..$ remove_line_break_before_round_closing_fun_dec    :function (pd)  
##   .. [list output truncated]
##  $ space            :List of 26
##   ..$ indent_braces                     :function (...)  
##   ..$ unindent_fun_dec                  :function (pd)  
##   ..$ indent_op                         :function (...)  
##   .. [list output truncated]
##   [list output truncated]</code></pre>
<p>We note that there are different types of transformer functions. <code>initialize</code> initializes some variables in the nested parse table (so it is not actually a transformer), and the other elements modify either spacing, line breaks or tokens. <code>use_raw_indention</code> is not a function, it is just an option. All transformer functions have a similar structure. Let’s take a look at one:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">tidyverse_style</span>()<span class="op">$</span>space<span class="op">$</span>remove_space_after_opening_paren</a></code></pre></div>
<pre><code>## function (pd_flat) 
## {
##     paren_after &lt;- pd_flat$token == &quot;'('&quot;
##     if (!any(paren_after)) 
##         return(pd_flat)
##     pd_flat$spaces[paren_after &amp; (pd_flat$newlines == 0L)] &lt;- 0L
##     pd_flat
## }
## &lt;bytecode: 0x7fae742b6fa8&gt;
## &lt;environment: namespace:styler&gt;</code></pre>
<p>As the name says, this function removes spaces after the opening parenthesis. But how? Its input is a <em>nest</em>. Since the visitor will go through all levels of nesting, we just need a function that can be applied to a <em>nest</em>, that is, to a parse table at one level of nesting. We can compute the nested parse table and look at one of the levels of nesting that is interesting for us (more on the data structure in the vignettes “Data structures” and “Manipulating the parse table”):</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb7-1" data-line-number="1">string_to_format &lt;-<span class="st"> &quot;call( 3)&quot;</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">pd &lt;-<span class="st"> </span>styler<span class="op">:::</span><span class="kw">compute_parse_data_nested</span>(string_to_format) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="st">  </span>styler<span class="op">:::</span><span class="kw">pre_visit</span>(<span class="kw">c</span>(default_style_guide_attributes))</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">pd<span class="op">$</span>child[[<span class="dv">1</span>]] <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="st">  </span><span class="kw">select</span>(token, terminal, text, newlines, spaces)</a></code></pre></div>
<pre><code>## # A tibble: 4 x 5
##   token terminal text  newlines spaces
##   &lt;chr&gt; &lt;lgl&gt;    &lt;chr&gt;    &lt;int&gt;  &lt;int&gt;
## 1 expr  FALSE    &quot;&quot;           0      0
## 2 '('   TRUE     (            0      1
## 3 expr  FALSE    &quot;&quot;           0      0
## 4 ')'   TRUE     )            0      0</code></pre>
<p><code>default_style_guide_attributes()</code> is called to initialize some variables, it does not actually transform the parse table.</p>
<p>All the function <code>remove_space_after_opening_paren()</code> now does is to look for the opening bracket and set the column <code>spaces</code> of the token to zero. Note that it is very important to check whether there is also a line break following after that token. If so, <code>spaces</code> should not be touched because of the way <code>spaces</code> and <code>newlines</code> are defined. <code>spaces</code> are the number of spaces after a token and <code>newlines</code>. Hence, if a line break follows, spaces are not EOL spaces, but rather the spaces directly before the next token. If there was a line break after the token and the rule did not check for that, indention for the token following <code>(</code> would be removed. This would be unwanted for example if <code>use_raw_indention</code> is set to <code>TRUE</code> (which means indention should not be touched). If we apply the rule to our parse table, we can see that the column <code>spaces</code> changes and is now zero for all tokens:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb9-1" data-line-number="1">styler<span class="op">:::</span><span class="kw">remove_space_after_opening_paren</span>(pd<span class="op">$</span>child[[<span class="dv">1</span>]]) <span class="op">%&gt;%</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="st">  </span><span class="kw">select</span>(token, terminal, text, newlines, spaces)</a></code></pre></div>
<pre><code>## # A tibble: 4 x 5
##   token terminal text  newlines spaces
##   &lt;chr&gt; &lt;lgl&gt;    &lt;chr&gt;    &lt;int&gt;  &lt;int&gt;
## 1 expr  FALSE    &quot;&quot;           0      0
## 2 '('   TRUE     (            0      0
## 3 expr  FALSE    &quot;&quot;           0      0
## 4 ')'   TRUE     )            0      0</code></pre>
<p>All top-level styling functions have a <code>style</code> argument (which defaults to <code>tidyverse_style</code>). If you check out the help file, you can see that the argument <code>style</code> is only used to create the default <code>transformers</code> argument, which defaults to <code>style(...)</code>. This allows for the styling options to be set without having to specify them inside the function passed to <code>transformers</code>.</p>
<p>Let’s clarify this with an example. The following yields the same result:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">all.equal</span>(</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="kw">style_text</span>(string_to_format, <span class="dt">transformers =</span> <span class="kw">tidyverse_style</span>(<span class="dt">strict =</span> <span class="ot">FALSE</span>)),</a>
<a class="sourceLine" id="cb11-3" data-line-number="3">  <span class="kw">style_text</span>(string_to_format, <span class="dt">style =</span> tidyverse_style, <span class="dt">strict =</span> <span class="ot">FALSE</span>),</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="kw">style_text</span>(string_to_format, <span class="dt">strict =</span> <span class="ot">FALSE</span>),</a>
<a class="sourceLine" id="cb11-5" data-line-number="5">)</a></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Now let’s do the whole styling of a string with just this one transformer introduced above. We do this by first creating a style guide with the designated wrapper function <code>create_style_guide()</code>. It takes transformer functions as input and returns them in a named list that meets the formal requirements for styling functions.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb13-1" data-line-number="1">space_after_opening_style &lt;-<span class="st"> </span><span class="cf">function</span>(are_you_sure) {</a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="kw">create_style_guide</span>(<span class="dt">space =</span> tibble<span class="op">::</span><span class="kw">lst</span>(<span class="dt">remove_space_after_opening_paren =</span> </a>
<a class="sourceLine" id="cb13-3" data-line-number="3">    <span class="cf">if</span> (are_you_sure) styler<span class="op">:::</span>remove_space_after_opening_paren</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  ))</a>
<a class="sourceLine" id="cb13-5" data-line-number="5">}</a>
<a class="sourceLine" id="cb13-6" data-line-number="6"><span class="kw">style_text</span>(<span class="st">&quot;call( 1,1)&quot;</span>, <span class="dt">style =</span> space_after_opening_style, <span class="dt">are_you_sure =</span> <span class="ot">FALSE</span>)  </a></code></pre></div>
<pre><code>## call( 1,1)</code></pre>
<p>Well, we probably want:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">style_text</span>(<span class="st">&quot;call( 1,1)&quot;</span>, <span class="dt">style =</span> space_after_opening_style, <span class="dt">are_you_sure =</span> <span class="ot">TRUE</span>)  </a></code></pre></div>
<pre><code>## call(1,1)</code></pre>
<p>Note that the return value of your <code>style</code> function may not contain <code>NULL</code> elements.</p>
<p>I hope you have acquired a basic understanding of how styler transforms code. You can provide your own transformer functions and use <code>create_style_guide()</code> to create customized code styling. If you do so, there are a few more things you should be aware of, which are described in the next section.</p>
</div>
<div id="implementation-details" class="section level1">
<h1>Implementation details</h1>
<p>For both spaces and line break information in the nested parse table, we use four attributes in total: <code>newlines</code>, <code>lag_newlines</code>, <code>spaces</code>, and <code>lag_spaces</code>. <code>lag_spaces</code> is created from <code>spaces</code> only just before the parse table is serialized, so it is not relevant for manipulating the parse table as described above. These columns are to some degree redundant, but with just lag or lead, we would lose information on the first or the last element respectively, so we need both.</p>
<p>The sequence in which styler applies rules on each level of nesting is given in the list below:</p>
<ul>
<li>call <code>default_style_guide_attributes()</code> to initialize some variables.</li>
<li>modify the line breaks (modifying <code>lag_newlines</code> only based on <code>token</code>, <code>token_before</code>, <code>token_after</code> and <code>text</code>).</li>
<li>modify the spaces (modifying <code>spaces</code> only based on <code>lag_newlines</code>, <code>newlines</code>, <code>multi_line</code>, <code>token</code>, <code>token_before</code>, <code>token_after</code> and <code>text</code>).</li>
<li>modify the tokens (based on <code>newlines</code> <code>lag_newlines</code>, <code>spaces</code> <code>multi_line</code>, <code>token</code>, <code>token_before</code>, <code>token_after</code> and <code>text</code>).</li>
<li>modify the indention by changing <code>indention_ref_id</code> (based on <code>newlines</code> <code>lag_newlines</code>, <code>spaces</code> <code>multi_line</code>, <code>token</code>, <code>token_before</code>, <code>token_after</code> and <code>text</code>).</li>
</ul>
<p>You can also look this up in the function that applies the transformers: <code>apply_transformers()</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb17-1" data-line-number="1">styler<span class="op">:::</span>apply_transformers</a></code></pre></div>
<pre><code>## function (pd_nested, transformers) 
## {
##     transformed_line_breaks &lt;- pre_visit(pd_nested, c(transformers$initialize, 
##         transformers$line_break))
##     transformed_updated_multi_line &lt;- post_visit(transformed_line_breaks, 
##         c(set_multi_line, update_newlines))
##     transformed_all &lt;- pre_visit(transformed_updated_multi_line, 
##         c(transformers$space, transformers$indention, transformers$token))
##     transformed_absolute_indent &lt;- context_to_terminals(transformed_all, 
##         outer_lag_newlines = 0L, outer_indent = 0L, outer_spaces = 0L, 
##         outer_indention_refs = NA)
##     transformed_absolute_indent
## }
## &lt;bytecode: 0x7fae78e543c8&gt;
## &lt;environment: namespace:styler&gt;</code></pre>
<p>This means that the order of the styling is clearly defined and it is for example not possible to modify line breaks based on spacing, because spacing will be set after line breaks are set. Do not rely on the column <code>col1</code>, <code>col2</code>, <code>line1</code> and <code>line2</code> in the parse table in any of your functions since these columns only reflect the position of tokens at the point of parsing, i.e. they are not kept up to date throughout the process of styling.</p>
<p>Also, as indicated above, work with <code>lag_newlines</code> only in your line break rules. For development purposes, you may also want to use the unexported function <code>test_collection()</code> to help you with testing your style guide. You can find more information in the help file for the function.</p>
<p>If you write functions that modify spaces, don’t forget to make sure that you don’t modify EOL spacing, since that is needed for <code>use_raw_indention</code>, as highlighted previously.</p>
<p>Finally, take note of the naming convention. All function names starting with <code>set-*</code> correspond to the <code>strict</code> option, that is, setting some value to an exact number. <code>add-*</code> is softer. For example, <code>add_spaces_around_op()</code>, only makes sure that there is at least one space around operators, but if the code to style contains multiple, the transformer will not change that.</p>
</div>
<div id="showcasing-the-development-of-a-styling-rule" class="section level1">
<h1>Showcasing the development of a styling rule</h1>
<p>For illustrative purposes, we create a new style guide that has one rule only: Curly braces are always on a new line. So for example:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb19-1" data-line-number="1">add_one &lt;-<span class="st"> </span><span class="cf">function</span>(x) {</a>
<a class="sourceLine" id="cb19-2" data-line-number="2">  x <span class="op">+</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">}</a></code></pre></div>
<p>Should be transformed to:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb20-1" data-line-number="1">add_one &lt;-<span class="st"> </span><span class="cf">function</span>(x) </a>
<a class="sourceLine" id="cb20-2" data-line-number="2">{</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  x <span class="op">+</span><span class="st"> </span><span class="dv">1</span></a>
<a class="sourceLine" id="cb20-4" data-line-number="4">}</a></code></pre></div>
<p>We first need to get familiar with the structure of the nested parse table. Note that the structure of the nested parse table is not affected by the position of line breaks and spaces. Let’s first create the nested parse table.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb21-1" data-line-number="1">code &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;add_one &lt;- function(x) { x + 1 }&quot;</span>)</a></code></pre></div>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb22-1" data-line-number="1">styler<span class="op">:::</span><span class="kw">create_tree</span>(code)</a></code></pre></div>
<pre><code>##                                              levelName
## 1  ROOT (token: short_text [lag_newlines/spaces] {id})
## 2   °--expr:  [0/0] {23}                              
## 3       ¦--expr:  [0/1] {3}                           
## 4       ¦   °--SYMBOL: add_o [0/0] {1}                
## 5       ¦--LEFT_ASSIGN: &lt;- [0/1] {2}                  
## 6       °--expr:  [0/0] {22}                          
## 7           ¦--FUNCTION: funct [0/0] {4}              
## 8           ¦--'(': ( [0/0] {5}                       
## 9           ¦--SYMBOL_FORMALS: x [0/0] {6}            
## 10          ¦--')': ) [0/1] {7}                       
## 11          °--expr:  [0/0] {19}                      
## 12              ¦--'{': { [0/1] {9}                   
## 13              ¦--expr:  [0/1] {16}                  
## 14              ¦   ¦--expr:  [0/1] {12}              
## 15              ¦   ¦   °--SYMBOL: x [0/0] {10}       
## 16              ¦   ¦--'+': + [0/1] {11}              
## 17              ¦   °--expr:  [0/0] {14}              
## 18              ¦       °--NUM_CONST: 1 [0/0] {13}    
## 19              °--'}': } [0/0] {15}</code></pre>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb24-1" data-line-number="1">pd &lt;-<span class="st"> </span>styler<span class="op">:::</span><span class="kw">compute_parse_data_nested</span>(code)</a></code></pre></div>
<p>The token of interest here has id number 10. Let’s navigate there. Since line break rules manipulate the lags <em>before</em> the token, we need to change <code>lag_newlines</code> at the token “‘{’”.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb25-1" data-line-number="1">pd<span class="op">$</span>child[[<span class="dv">1</span>]]<span class="op">$</span>child[[<span class="dv">3</span>]]<span class="op">$</span>child[[<span class="dv">5</span>]]</a></code></pre></div>
<pre><code>## # A tibble: 3 x 15
##      id pos_id line1  col1 line2  col2 parent token terminal text  short
##   &lt;int&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;chr&gt; &lt;lgl&gt;    &lt;chr&gt; &lt;chr&gt;
## 1     9     11     1    24     1    24     19 '{'   TRUE     {     {    
## 2    16     12     1    26     1    30     19 expr  FALSE    &quot;&quot;    &quot;&quot;   
## 3    15     18     1    32     1    32     19 '}'   TRUE     }     }    
## # ... with 4 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   internal &lt;lgl&gt;, child &lt;list&gt;</code></pre>
<p>Remember what we said above: A transformer takes a flat parse table as input, updates it and returns it. So here it’s actually simple:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb27-1" data-line-number="1">set_line_break_before_curly_opening &lt;-<span class="st"> </span><span class="cf">function</span>(pd_flat) {</a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  op &lt;-<span class="st"> </span>pd_flat<span class="op">$</span>token <span class="op">%in%</span><span class="st"> &quot;'{'&quot;</span></a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  pd_flat<span class="op">$</span>lag_newlines[op] &lt;-<span class="st"> </span>1L</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  pd_flat</a>
<a class="sourceLine" id="cb27-5" data-line-number="5">}</a></code></pre></div>
<p>Almost done. Now, the last thing we need to do is to use <code>create_style_guide()</code> to create our style guide consisting of that function.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb28-1" data-line-number="1">set_line_break_before_curly_opening_style &lt;-<span class="st"> </span><span class="cf">function</span>() {</a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  <span class="kw">create_style_guide</span>(<span class="dt">line_break =</span> <span class="kw">lst</span>(set_line_break_before_curly_opening))</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">}</a></code></pre></div>
<p>Now you can style your string according to it.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb29-1" data-line-number="1"><span class="kw">style_text</span>(code, <span class="dt">style =</span> set_line_break_before_curly_opening_style)</a></code></pre></div>
<pre><code>## add_one &lt;- function(x)
## { x + 1 }</code></pre>
<p>Note that when removing line breaks, always take care of comments, since you don’t want:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb31-1" data-line-number="1">a &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="co"># comments should remain EOL</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">{ </a>
<a class="sourceLine" id="cb31-3" data-line-number="3">  <span class="dv">3</span></a>
<a class="sourceLine" id="cb31-4" data-line-number="4">}</a></code></pre></div>
<p>To become:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb32-1" data-line-number="1">a &lt;-<span class="st"> </span><span class="cf">function</span>() <span class="co"># comments should remain EOL { </span></a>
<a class="sourceLine" id="cb32-2" data-line-number="2">  <span class="dv">3</span></a>
<a class="sourceLine" id="cb32-3" data-line-number="3"><span class="er">}</span></a></code></pre></div>
<p>The easiest way of taking care of that is not applying the rule if there is a comment before the token of interest, which can be checked for within your transformer function. The transformer function from the tidyverse style that removes line breaks before the curly opening bracket looks as follows:</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode r"><code class="sourceCode r"><a class="sourceLine" id="cb33-1" data-line-number="1">styler<span class="op">:::</span>remove_line_break_before_curly_opening</a></code></pre></div>
<pre><code>## function (pd) 
## {
##     rm_break &lt;- (pd$token_after == &quot;'{'&quot;) &amp; (pd$token != &quot;COMMENT&quot;)
##     pd$lag_newlines[lag(rm_break)] &lt;- 0L
##     pd
## }
## &lt;bytecode: 0x7fae77305e48&gt;
## &lt;environment: namespace:styler&gt;</code></pre>
<p>With our example function <code>set_line_break_before_curly_opening()</code> we don’t need to worry about that as we are only adding line breaks, but we don’t remove them.</p>
</div>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
