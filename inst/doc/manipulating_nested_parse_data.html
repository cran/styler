<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />

<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Lorenz Walthert" />

<meta name="date" content="2017-08-23" />

<title>Manipulating the nested parse table</title>






<link href="data:text/css;charset=utf-8,body%20%7B%0Abackground%2Dcolor%3A%20%23fff%3B%0Amargin%3A%201em%20auto%3B%0Amax%2Dwidth%3A%20700px%3B%0Aoverflow%3A%20visible%3B%0Apadding%2Dleft%3A%202em%3B%0Apadding%2Dright%3A%202em%3B%0Afont%2Dfamily%3A%20%22Open%20Sans%22%2C%20%22Helvetica%20Neue%22%2C%20Helvetica%2C%20Arial%2C%20sans%2Dserif%3B%0Afont%2Dsize%3A%2014px%3B%0Aline%2Dheight%3A%201%2E35%3B%0A%7D%0A%23header%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0A%23TOC%20%7B%0Aclear%3A%20both%3B%0Amargin%3A%200%200%2010px%2010px%3B%0Apadding%3A%204px%3B%0Awidth%3A%20400px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Aborder%2Dradius%3A%205px%3B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Afont%2Dsize%3A%2013px%3B%0Aline%2Dheight%3A%201%2E3%3B%0A%7D%0A%23TOC%20%2Etoctitle%20%7B%0Afont%2Dweight%3A%20bold%3B%0Afont%2Dsize%3A%2015px%3B%0Amargin%2Dleft%3A%205px%3B%0A%7D%0A%23TOC%20ul%20%7B%0Apadding%2Dleft%3A%2040px%3B%0Amargin%2Dleft%3A%20%2D1%2E5em%3B%0Amargin%2Dtop%3A%205px%3B%0Amargin%2Dbottom%3A%205px%3B%0A%7D%0A%23TOC%20ul%20ul%20%7B%0Amargin%2Dleft%3A%20%2D2em%3B%0A%7D%0A%23TOC%20li%20%7B%0Aline%2Dheight%3A%2016px%3B%0A%7D%0Atable%20%7B%0Amargin%3A%201em%20auto%3B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dcolor%3A%20%23DDDDDD%3B%0Aborder%2Dstyle%3A%20outset%3B%0Aborder%2Dcollapse%3A%20collapse%3B%0A%7D%0Atable%20th%20%7B%0Aborder%2Dwidth%3A%202px%3B%0Apadding%3A%205px%3B%0Aborder%2Dstyle%3A%20inset%3B%0A%7D%0Atable%20td%20%7B%0Aborder%2Dwidth%3A%201px%3B%0Aborder%2Dstyle%3A%20inset%3B%0Aline%2Dheight%3A%2018px%3B%0Apadding%3A%205px%205px%3B%0A%7D%0Atable%2C%20table%20th%2C%20table%20td%20%7B%0Aborder%2Dleft%2Dstyle%3A%20none%3B%0Aborder%2Dright%2Dstyle%3A%20none%3B%0A%7D%0Atable%20thead%2C%20table%20tr%2Eeven%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Ap%20%7B%0Amargin%3A%200%2E5em%200%3B%0A%7D%0Ablockquote%20%7B%0Abackground%2Dcolor%3A%20%23f6f6f6%3B%0Apadding%3A%200%2E25em%200%2E75em%3B%0A%7D%0Ahr%20%7B%0Aborder%2Dstyle%3A%20solid%3B%0Aborder%3A%20none%3B%0Aborder%2Dtop%3A%201px%20solid%20%23777%3B%0Amargin%3A%2028px%200%3B%0A%7D%0Adl%20%7B%0Amargin%2Dleft%3A%200%3B%0A%7D%0Adl%20dd%20%7B%0Amargin%2Dbottom%3A%2013px%3B%0Amargin%2Dleft%3A%2013px%3B%0A%7D%0Adl%20dt%20%7B%0Afont%2Dweight%3A%20bold%3B%0A%7D%0Aul%20%7B%0Amargin%2Dtop%3A%200%3B%0A%7D%0Aul%20li%20%7B%0Alist%2Dstyle%3A%20circle%20outside%3B%0A%7D%0Aul%20ul%20%7B%0Amargin%2Dbottom%3A%200%3B%0A%7D%0Apre%2C%20code%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0Aborder%2Dradius%3A%203px%3B%0Acolor%3A%20%23333%3B%0Awhite%2Dspace%3A%20pre%2Dwrap%3B%20%0A%7D%0Apre%20%7B%0Aborder%2Dradius%3A%203px%3B%0Amargin%3A%205px%200px%2010px%200px%3B%0Apadding%3A%2010px%3B%0A%7D%0Apre%3Anot%28%5Bclass%5D%29%20%7B%0Abackground%2Dcolor%3A%20%23f7f7f7%3B%0A%7D%0Acode%20%7B%0Afont%2Dfamily%3A%20Consolas%2C%20Monaco%2C%20%27Courier%20New%27%2C%20monospace%3B%0Afont%2Dsize%3A%2085%25%3B%0A%7D%0Ap%20%3E%20code%2C%20li%20%3E%20code%20%7B%0Apadding%3A%202px%200px%3B%0A%7D%0Adiv%2Efigure%20%7B%0Atext%2Dalign%3A%20center%3B%0A%7D%0Aimg%20%7B%0Abackground%2Dcolor%3A%20%23FFFFFF%3B%0Apadding%3A%202px%3B%0Aborder%3A%201px%20solid%20%23DDDDDD%3B%0Aborder%2Dradius%3A%203px%3B%0Aborder%3A%201px%20solid%20%23CCCCCC%3B%0Amargin%3A%200%205px%3B%0A%7D%0Ah1%20%7B%0Amargin%2Dtop%3A%200%3B%0Afont%2Dsize%3A%2035px%3B%0Aline%2Dheight%3A%2040px%3B%0A%7D%0Ah2%20%7B%0Aborder%2Dbottom%3A%204px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Apadding%2Dbottom%3A%202px%3B%0Afont%2Dsize%3A%20145%25%3B%0A%7D%0Ah3%20%7B%0Aborder%2Dbottom%3A%202px%20solid%20%23f7f7f7%3B%0Apadding%2Dtop%3A%2010px%3B%0Afont%2Dsize%3A%20120%25%3B%0A%7D%0Ah4%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23f7f7f7%3B%0Amargin%2Dleft%3A%208px%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Ah5%2C%20h6%20%7B%0Aborder%2Dbottom%3A%201px%20solid%20%23ccc%3B%0Afont%2Dsize%3A%20105%25%3B%0A%7D%0Aa%20%7B%0Acolor%3A%20%230033dd%3B%0Atext%2Ddecoration%3A%20none%3B%0A%7D%0Aa%3Ahover%20%7B%0Acolor%3A%20%236666ff%3B%20%7D%0Aa%3Avisited%20%7B%0Acolor%3A%20%23800080%3B%20%7D%0Aa%3Avisited%3Ahover%20%7B%0Acolor%3A%20%23BB00BB%3B%20%7D%0Aa%5Bhref%5E%3D%22http%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0Aa%5Bhref%5E%3D%22https%3A%22%5D%20%7B%0Atext%2Ddecoration%3A%20underline%3B%20%7D%0A%0Acode%20%3E%20span%2Ekw%20%7B%20color%3A%20%23555%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Edt%20%7B%20color%3A%20%23902000%3B%20%7D%20%0Acode%20%3E%20span%2Edv%20%7B%20color%3A%20%2340a070%3B%20%7D%20%0Acode%20%3E%20span%2Ebn%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Efl%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Ech%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Est%20%7B%20color%3A%20%23d14%3B%20%7D%20%0Acode%20%3E%20span%2Eco%20%7B%20color%3A%20%23888888%3B%20font%2Dstyle%3A%20italic%3B%20%7D%20%0Acode%20%3E%20span%2Eot%20%7B%20color%3A%20%23007020%3B%20%7D%20%0Acode%20%3E%20span%2Eal%20%7B%20color%3A%20%23ff0000%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%0Acode%20%3E%20span%2Efu%20%7B%20color%3A%20%23900%3B%20font%2Dweight%3A%20bold%3B%20%7D%20%20code%20%3E%20span%2Eer%20%7B%20color%3A%20%23a61717%3B%20background%2Dcolor%3A%20%23e3d2d2%3B%20%7D%20%0A" rel="stylesheet" type="text/css" />

</head>

<body>




<h1 class="title toc-ignore">Manipulating the nested parse table</h1>
<h4 class="author"><em>Lorenz Walthert</em></h4>
<h4 class="date"><em>2017-08-23</em></h4>



<pre><code>library(&quot;dplyr&quot;)
library(&quot;purrr&quot;)
pkgload::load_all()</code></pre>
<p>This vignette builds on the vignette “Data Structures” and discusses how to go forward with the nested structure of the parse data. In order to compute the white space information in a nested data structure, we need a recursion. We use a <a href="https://en.wikipedia.org/wiki/Visitor_pattern">visitor approach</a> to separate the algorithm (computing white space information) from the object (nested) data structure. The function <code>create_filler()</code> can then be used to add white space information on every level of nesting within the nested parse data if applied in combination with the visitor. <code>visitor()</code> takes a object to operate on and a list of functions. Each function is applied at the current level of nesting before the next level of nesting is entered.</p>
<pre><code>pre_visit

## function(pd_nested, funs) {
##   if (is.null(pd_nested)) return()
##   pd_transformed &lt;- visit_one(pd_nested, funs)
## 
##   pd_transformed$child &lt;- map(pd_transformed$child, pre_visit, funs = funs)
##   pd_transformed
## }
## &lt;environment: namespace:styler&gt;

visit_one

## function(pd_flat, funs) {
##   reduce(funs, function(x, fun) fun(x),
##          .init = pd_flat)
## }
## &lt;environment: namespace:styler&gt;</code></pre>
<p>This comes with two advantages.</p>
<ul>
<li>We don’t need a *_nested() version of every function we want to apply to the parse tables, in particular the rules in R/rules.R</li>
<li>We go through the whole structure only once (instead of every *_nested() function going through it once, which is more efficient in terms of speed.</li>
</ul>
<p><code>create_filler()</code> was adapted to also initialize indention and lag_newlines.</p>
<pre><code>create_filler

## function(pd_flat) {
## 
##   pd_flat$line3 &lt;- lead(pd_flat$line1, default = tail(pd_flat$line2, 1))
##   pd_flat$col3 &lt;- lead(pd_flat$col1, default = tail(pd_flat$col2, 1) + 1L)
##   pd_flat$newlines &lt;- pd_flat$line3 - pd_flat$line2
##   pd_flat$lag_newlines &lt;- lag(pd_flat$newlines, default = 0L)
##   pd_flat$col2_nl &lt;- if_else(pd_flat$newlines &gt; 0L, 0L, pd_flat$col2)
##   pd_flat$spaces &lt;- pd_flat$col3 - pd_flat$col2_nl - 1L
##   pd_flat$multi_line &lt;- ifelse(pd_flat$terminal, FALSE, NA)
##   pd_flat$indention_ref_id &lt;- NA
##   ret &lt;- pd_flat[, !(names(pd_flat) %in% c(&quot;line3&quot;, &quot;col3&quot;, &quot;col2_nl&quot;))]
## 
## 
##   if (!(&quot;indent&quot; %in% names(ret))) {
##     ret$indent &lt;- 0
##   }
## 
##   if (any(ret$spaces &lt; 0L)) {
##     stop(&quot;Invalid parse data&quot;)
##   }
## 
##   ret
## }
## &lt;environment: namespace:styler&gt;

code &lt;- &quot;a &lt;- function(x) { if(x &gt; 1) { 1+1 } else {x} }&quot;
pd_nested &lt;- compute_parse_data_nested(code)
pd_nested_enhanced &lt;- pre_visit(pd_nested, c(create_filler))
pd_nested_enhanced

## # A tibble: 1 x 20
##   line1  col1 line2  col2    id parent token terminal  text short
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1     1     1    47    49      0  expr    FALSE            
## # ... with 10 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   internal &lt;lgl&gt;, child &lt;list&gt;, newlines &lt;int&gt;, lag_newlines &lt;int&gt;,
## #   spaces &lt;int&gt;, multi_line &lt;lgl&gt;, indention_ref_id &lt;lgl&gt;, indent &lt;dbl&gt;</code></pre>
<p>As a next step, we need to find a way to serialize the nested tibble, or in other words, to transform it to its character vector representation. As a starting point, consider the function <code>serialize</code> that was introduced in the vignette “Data Structures”.</p>
<pre><code>serialize &lt;- function(x) {
  out &lt;- Map(
    function(terminal, text, child) {
      if (terminal)
        text
      else
        serialize(child)
    },
    x$terminal, x$text, x$child
  )
  out
}

serialize(pd_nested) %&gt;% unlist

##  [1] &quot;a&quot;        &quot;&lt;-&quot;       &quot;function&quot; &quot;(&quot;        &quot;x&quot;        &quot;)&quot;       
##  [7] &quot;{&quot;        &quot;if&quot;       &quot;(&quot;        &quot;x&quot;        &quot;&gt;&quot;        &quot;1&quot;       
## [13] &quot;)&quot;        &quot;{&quot;        &quot;1&quot;        &quot;+&quot;        &quot;1&quot;        &quot;}&quot;       
## [19] &quot;else&quot;     &quot;{&quot;        &quot;x&quot;        &quot;}&quot;        &quot;}&quot;</code></pre>
<p><code>serialize</code> can be combined with <code>serialize_parse_data_flat</code>. The latter pastes together the column “text” of a flat parse table by taking into account space and line break information, splits the string by line break and returns it.</p>
<pre><code>serialize_parse_data_flat

## function(pd_flat) {
##   pd_flat %&gt;%
##     summarize_(
##       text_ws = ~paste0(
##         text, newlines_and_spaces(newlines, spaces),
##         collapse = &quot;&quot;)) %&gt;%
##     .[[&quot;text_ws&quot;]] %&gt;%
##     strsplit(&quot;\n&quot;, fixed = TRUE) %&gt;%
##     .[[1L]]
## }
## &lt;environment: namespace:styler&gt;</code></pre>
<p>However, things get a bit more complicated, mainly because line break and white space information is not only contained in the terminal tibbles of the nested parse data, but even before, as the following example shows.</p>
<pre><code>pd_nested_enhanced$child[[1]]

## # A tibble: 3 x 20
##   line1  col1 line2  col2    id parent       token terminal  text short
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;       &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1     1     1     1     3     49        expr    FALSE            
## 2     1     3     1     4     2     49 LEFT_ASSIGN     TRUE    &lt;-    &lt;-
## 3     1     6     1    47    48     49        expr    FALSE            
## # ... with 10 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   internal &lt;lgl&gt;, child &lt;list&gt;, newlines &lt;int&gt;, lag_newlines &lt;int&gt;,
## #   spaces &lt;int&gt;, multi_line &lt;lgl&gt;, indention_ref_id &lt;lgl&gt;, indent &lt;dbl&gt;

pd_nested_enhanced$child[[1]]$child[[1]]

## # A tibble: 1 x 20
##   line1  col1 line2  col2    id parent  token terminal  text short
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;  &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1     1     1     1     1      3 SYMBOL     TRUE     a     a
## # ... with 10 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   child &lt;list&gt;, internal &lt;lgl&gt;, newlines &lt;int&gt;, lag_newlines &lt;int&gt;,
## #   spaces &lt;int&gt;, multi_line &lt;lgl&gt;, indention_ref_id &lt;lgl&gt;, indent &lt;dbl&gt;</code></pre>
<p>After “a” in <code>code</code>, there is a space, but this information is not contained in the tibble where we find the terminal “a”. In general, we must add newlines and spaces values <em>after</em> we computed character vector representation of the expression. In our example: we know that there is a space after the non-terminal “a” by looking at <code>pd_nested_enhanced$child[[1]]</code>. Therefore, we need to add this space to the very last terminal within <code>pd_nested_enhanced$child[[1]]</code> before we collapse everything together.</p>
<pre><code>serialize_parse_data_nested_helper

## function(pd_nested, pass_indent) {
##   out &lt;- pmap(list(pd_nested$terminal, pd_nested$text, pd_nested$child,
##                    pd_nested$spaces, pd_nested$lag_newlines, pd_nested$indent),
##               function(terminal, text, child, spaces, lag_newlines, indent) {
##                 total_indent &lt;- pass_indent + indent
##                 preceding_linebreak &lt;- if_else(lag_newlines &gt; 0, 1, 0)
##                 if (terminal) {
##                   c(add_newlines(lag_newlines),
##                     add_spaces(total_indent * preceding_linebreak),
##                     text,
##                     add_spaces(spaces))
##                 } else {
##                   c(add_newlines(lag_newlines),
##                     add_spaces(total_indent * preceding_linebreak),
##                     serialize_parse_data_nested_helper(child, total_indent),
##                     add_spaces(spaces))
##                 }
##               }
##   )
##   out
## }
## &lt;environment: namespace:styler&gt;

serialize_parse_data_nested

## function(pd_nested) {
##   out &lt;- c(add_newlines(start_on_line(pd_nested) - 1),
##            serialize_parse_data_nested_helper(pd_nested, pass_indent = 0)) %&gt;%
##     unlist() %&gt;%
##     paste0(collapse = &quot;&quot;) %&gt;%
##     strsplit(&quot;\n&quot;, fixed = TRUE) %&gt;%
##     .[[1L]] %&gt;%
##     trimws(which = &quot;right&quot;)
##   out
## }
## &lt;environment: namespace:styler&gt;</code></pre>
<p>Before we are done, we need to add information regarding indention to the parse table. We can add indention after every line break that comes after a round bracket with <code>indent_round()</code>. And then serialize it.</p>
<pre><code>pre_visit(pd_nested, 
               c(create_filler, 
                 purrr::partial(indent_round, indent_by = 2)))

## # A tibble: 1 x 20
##   line1  col1 line2  col2    id parent token terminal  text short
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;chr&gt;    &lt;lgl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1     1     1    47    49      0  expr    FALSE            
## # ... with 10 more variables: token_before &lt;chr&gt;, token_after &lt;chr&gt;,
## #   internal &lt;lgl&gt;, child &lt;list&gt;, newlines &lt;int&gt;, lag_newlines &lt;int&gt;,
## #   spaces &lt;int&gt;, multi_line &lt;lgl&gt;, indention_ref_id &lt;lgl&gt;, indent &lt;dbl&gt;</code></pre>
<p>We can see how indention works with a more complicated example</p>
<pre><code>indented &lt;- c(
  &quot;call(&quot;, 
  &quot;  1,&quot;, 
  &quot;  call2(&quot;, 
  &quot;    2, 3,&quot;, 
  &quot;    call3(1, 2, 22),&quot;, 
  &quot;    5&quot;, 
  &quot;  ),&quot;, 
  &quot;  144&quot;,
  &quot;)&quot;
)

not_indented &lt;- trimws(indented)
back_and_forth &lt;- not_indented %&gt;%
  compute_parse_data_nested() %&gt;%
  pre_visit(c(create_filler, 
        purrr::partial(indent_round, indent_by = 2))) %&gt;%
  serialize_parse_data_nested()

identical(indented, back_and_forth)

## [1] TRUE</code></pre>



<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
